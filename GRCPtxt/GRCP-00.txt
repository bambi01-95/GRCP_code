Graduate Research Consultation Project
======================================

0.  Introduction and context
----------------------------

Goal: create a "maximally simple" framework for computation based on a few
fundamental principles.  Our data and program representations, and the
evaluation mechanism to perform computations, will be sufficiently powerful to
represent (for example) the Factorial function

    factorial(n) = if n < 2 then 1 else n * factorial(n - 1)

and to evaluate an expression such as:

    factorial(5)				=>  120

It will also be powerful enough to perform unlimited meta-programming
(inspection, modification, and generation of programs at run time).

In our program representation, Integers represent themselves.

    2  1  5  60

Symbols (identifiers) are names representing either a variable or a built-in
operator.  They consist of one or more non-blank characters, except for the
special characters used for lists.

    factorial  n  if  <  *  -

Lists are sequences of zero or more values delimited by parentheses, '(' and
')', and separated by blank space.  Lists can contain sub-lists.

    (2 1 (factorial n 5) (60 if <) * -)

Lists will be used to represent an operator (or function) being applied to zero
or more operands.  (This is only a small change to the usual mathematical
notation for functions.)

    expression			representation
    ----------			--------------
    f(x)			    (f x)
    g(p, q, r)			(g p q r)
    3 + 4 == +(3, 4)	(+ 3 4)
    n - 1 == -(n, 1)	(- n 1)

Unnecessary words can be omitted from the representation.  For example, the
conditional operator "if" does not need the words "then" and "else".  The
position of the operands is enough to indicate which is the "then" part and
which is the "else" part.

    expression			representation
    ----------			--------------
    if P then X else Y		(if P X Y)

The representation for the factorial(n) function body is therefore:

    (if (< n 2)
        1
	(* n (factorial (- n 1))))

Two more special operators are needed.  The special operator "define"
associates a name with a value.

    meaning			representation
    -------			--------------
    x = 6*7			(define x (* 6 7))		=> x == 42

The special operator "lambda" delays the evaluation of an expression, creating
a representation for a function.  (The name "lambda" comes from the Lambda
Calculus, invented by Alonso Church, which is the mathematical foundation for
our representation and evaluation mechanism.)  The list

    (lambda (a b c) d)

represents a function with parameters a, b, and c whose body is the value d.
Combining this with "define" lets us give names to a functions:

    expression			representation
    ----------			--------------
    add(x, y) = x + y		(define add (lambda (x y) (+ x y)))

We can now write our entire factorial-printing program

    factorial(n) = if n < 2 then 1 else n * factorial(n - 1)

    factorial(5)				=> 60

using the list-based representation:

    (define factorial
      (lambda (n)
        (if (< n 2)
	    1
	    (* n (factorial (- n 1))))))

    (factorial 5)				=> 60

This project takes you through the steps needed to program (in C) everything
needed to implement the representation and evaluation mechanisms described
above.  The "tiny language" you will obtain is an excellent platform for
experiments with programming language paradigms, syntax, semantics, and
meta-programming.

----------------------------------------------------------------

Note: If you know something about parsing then you might have already noticed
that our program representation is equivalent to a parse tree, such as would be
generated by a parser for a language using more conventional program notation.
Our "atomic" values (integers and symbols) are the leaves of the parse tree.
Lists are the interior nodes, with the first element of the list representing
the operator and the remaining elements being the children of that node.

    (define x (* 6 7)) === (DEFINE)
                             /  \
                            X   (*)
                                / \
                               6   7
